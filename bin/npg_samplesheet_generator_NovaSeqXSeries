#!/usr/bin/env perl

use strict;
use warnings;
use FindBin qw($Bin);
use lib ( -d "$Bin/../lib/perl5" ? "$Bin/../lib/perl5" : "$Bin/../lib" );
use Readonly;
use Carp;
use Text::CSV;
use List::MoreUtils qw(any none);
use List::Util qw(first max);
use Getopt::Long;
use Pod::Usage;

use st::api::lims;

our $VERSION = '0';

Readonly::Scalar my $READ1_LENGTH => 151;
Readonly::Scalar my $READ2_LENGTH => 151;
Readonly::Scalar my $BATCH_ID     => 96_802;
Readonly::Scalar my $FILE_NAME    => qq[samplesheet_${BATCH_ID}.csv];
Readonly::Scalar my $LIST_INDEX_TAG1  => 2;
Readonly::Scalar my $LIST_INDEX_TAG2  => 3;
Readonly::Scalar my $LIST_INDEX_REF   => 4;
Readonly::Array  my @RNA_ANALYSES     => qw(tophat2 star hisat2);
Readonly::Array  my @VAR_CALL_MODES   =>
    qw(None SmallVariantCaller AllVariantCallers);

Readonly::Hash my %REFERENCE_MAPING => (
    'Homo_sapiens'=> 'hg38-alt_masked.cnv.graph.hla.rna-8-*-2',
    'Escherichia_coli' => 'eschColi_K12_1-rna-8-*-2',
    'PhiX' => 'phix-rna-8-*-2',
);

# The version of the software currently installed on the system,
# using all three integers included in the version name.
Readonly::Scalar my $SOFTWARE_VERSION => '4.1.5'; # TODO

my $variant_calling_mode = $VAR_CALL_MODES[0];
my $help;
GetOptions (
            'help'      => \$help,
            'varcall=s' => \$variant_calling_mode,
           );
if ($help) { pod2usage(0); }

if (none { $variant_calling_mode eq $_ } @VAR_CALL_MODES) {
    croak "Uknown mode for variang calling - $variant_calling_mode";
}

my $index1_length = 0;
my $index2_length = 0;

sub process_lims_data {
  my ($batch_id) = @_;

  my @lane_lims =st::api::lims->new(
    id_flowcell_lims => $batch_id,
    driver_type => q[ml_warehouse]
  )->children();

  my @products = ();

  for my $lane (@lane_lims) {
    my $position = $lane->position;
    my @lane_products = $lane->is_pool ? $lane->children() : ($lane);
    for my $p (@lane_products) {
      my $i7 = $p->tag_sequences->[0] || q();
      my $i5 = $p->tag_sequences->[1] || q();
      if ($i5) { # reverse-complement
        $i5 =~ tr/[ACGT]/[TGCA]/;
        $i5 = reverse $i5;
      }
      push @products, [
        $position,
        $p->sample_name,
        $i7,
        $i5,
        $p->reference_genome() || q(),
        $p->library_type() || q()
      ];
    }
  }

  # Assign variables that were defined in the parent scope.
  $index1_length = max (map { length $_->[$LIST_INDEX_TAG1] } @products);
  $index2_length = max (map { length $_->[$LIST_INDEX_TAG2] } @products);

  # sort by sample ID
  @products = sort { $a->[1] cmp $b->[1] } @products;

  return \@products;
}

my $products = process_lims_data($BATCH_ID);

my @all_lines = ();

my $add_line = sub {
  my @columns = @_;
  push @all_lines, @columns ? \@columns : [];
};

# Header section
$add_line->(qw([Header]));
# How important is this name? Is the runfolder name derived from this?
$add_line->(q[RunName], qq[Run_${BATCH_ID}]); # TODO
$add_line->(qw(InstrumentPlatform NovaSeqXSeries));
# NovaSeqxPlus or NovaSeqX. 
$add_line->(qw(InstrumentType NovaSeqX)); # TODO
$add_line->();

# Reads section                                                              
$add_line->(qw([Reads]));
$add_line->(q[Read1Cycles], $READ1_LENGTH);
$add_line->(q[Read2Cycles], $READ2_LENGTH);
if ($index1_length) {
  $add_line->(('Index1Cycles', $index1_length));
  if ($index2_length) {
    $add_line->(('Index2Cycles', $index2_length));
  }
}
$add_line->();

# Sequencing_Settings section
$add_line->(qw([Sequencing_Settings]));
# TODO. We might want to change this value or not to have it.
# $add_line->(qw(LibraryPrepKits
#  IlluminaDNAPCRFree;NexteraXT;SingleCellATACLibraryKit1;IlluminaDNAPrep));
$add_line->();

###############################
# BCLConvert_Settings section
###############################
$add_line->(qw([BCLConvert_Settings]));
$add_line->((q[SoftwareVersion], $SOFTWARE_VERSION));

# Not clear what CLI analysis option thie coresponds to.
# Looks likely to be a list of lanes to run a tag collision check.
# According to @srl, bcl-covert tries to correct one error by default
# but it checks the tags allow this I.e that they all differ by at least
# 3 bases, if they don't it disables the error correction
# $add_line->(qw(CombinedIndexCollisionCheck 1;3;4;6));

# CreateFastqForIndexReads might be an option. Do we need these files?
$add_line->(qw(CreateFastqForIndexReads 1));
# When 1 will be appropriate for this trim?
$add_line->(qw(TrimUMI 0));
# gzip is the other compression options
$add_line->(qw(FastqCompressionFormat dragen));

# Barcode mismatch tolerances, the default is 1.
# These settings can be omitted
if ($index1_length) {
  $add_line->(qw(BarcodeMismatchesIndex1 1));
  if ($index2_length) {
    $add_line->(qw(BarcodeMismatchesIndex2 1));
  }
}
# Adapter trimming settings. The sequence of the Read 1 (or 2) adapter
# to be masked or trimmed. To trim multiple adapters, separate the sequences
# with a plus sign (+) indicating independent adapters that must be
# independently assessed for masking or trimming for each read.
# Characters must be A, C, G, or T.
# It seems that this settign can also be a column in teh data section
#
# $add_line->(qw(AdapterRead1 SOME));
# $add_line->(qw(AdapterRead2 OTHER));

$add_line->();

##########################
# BCLConvert_Data section
##########################
$add_line->(qw([BCLConvert_Data]));

# Must have columns: Lane, SampleID, Index, Index2, provided the index reads
# were performed.
# Optional columns: OverrideCycles, AdapterRead1, AdapterRead2
# The rows are sorted by SampleID

my @data_header = qw(Lane SampleID);
if ($index1_length) {
  push @data_header, q[Index];
  if ($index2_length) {
    push @data_header, q[Index2];
  }
  push @data_header, q[OverrideCycles];
}
$add_line->(@data_header);

# Override Cycles - Specifies the sequencing and indexing cycles to be used
# when processing the sequencing data. Must adhere to the
# following requirements:
# - Must be same number of fields (delimited by semicolon) as sequencing and
#   indexing reads specified in RunInfo.xml or Reads section.
# - Indexing reads are specified with I, sequencing reads are specified with
#   Y, UMI cycles are specified with U, and trimmed reads are specified with N.
# - The number of cycles specified for each read must equal the number of
#   cycles specified for that read in the RunInfo.xml file.
# - Only one Y or I sequence can be specified per read.

my $index_override = sub {
  my ($max_length, $barcode) = @_;
  my $i_cycles_number = length $barcode;
  my $n_cycles_number = $max_length - $i_cycles_number;
  $i_cycles_number -= $n_cycles_number;
  my $expression = q[];
  if ($i_cycles_number) {
    $expression .= q[I] . $i_cycles_number;
  }
  if ($n_cycles_number) {
    $expression .= q[N] . $n_cycles_number;
  }
  return $expression;
};

for my $product ( @{$products} ) {

  my @product_data = ($product->[0], $product->[1]);

  my @override_cycles = ();
  # Not accounting for UMI cycles for now.
  if ($index1_length) {
    my $i7 = $product->[$LIST_INDEX_TAG1];
    push @product_data, $i7;
    push @override_cycles, q[Y] . $READ1_LENGTH;
    push @override_cycles,
      $index_override->($index1_length, $i7);
    if ($index2_length) {
      my $i5 = $product->[$LIST_INDEX_TAG2];
      push @product_data, $i5;
      push @override_cycles,
        $index_override->($index2_length, $i5);
    }
    push @override_cycles, q[Y] . $READ2_LENGTH;
  }
  if (@override_cycles) {
    push @product_data, join q[;], @override_cycles;
  }
  $add_line->(@product_data);
}

$add_line->();

##################################
# DragenGermline_Settings Section
##################################

# Probably it's OK to have this section unconditionally.
$add_line->(qw([DragenGermline_Settings]));
$add_line->(q[SoftwareVersion], $SOFTWARE_VERSION);
# Accepted values are bam, cram, or none. Selecting none produces
# no map/align output. Not clear whether this can be set per sample.
$add_line->(qw(MapAlignOutFormat cram));
# Accepted values are true or false. Not clear whether this can be
# set per sample.
$add_line->(qw(KeepFastq FALSE));

$add_line->();

#########################################
# DragenGermline_Data Section
# This section is definitely conditional.
#########################################

# Only non-RNA samples should be listed in this section.
# A very simple test:

my $do_rna_alignment_test = sub {
  my $r = shift;
  return any { $_ =~ $r } @RNA_ANALYSES;
};

my @references = map { $_->[$LIST_INDEX_REF] } @{$products};
my $do_rna_alignment = 0;
my $do_germline_alignment = 0;
for my $r (@references) {
  if ( $do_rna_alignment_test->($r) ) {
    $do_rna_alignment = 1;
  } else {
    $do_germline_alignment = 1;
  }
  if ($do_rna_alignment && $do_germline_alignment) {
    last;
  }
}

# DRAGEN aligner info:
# https://support-docs.illumina.com/SW/DRAGEN_v40/Content/SW/DRAGEN/GraphMapper_fDG.htm
# Prepare a reference:
# https://support-docs.illumina.com/SW/DRAGEN_v41/Content/SW/DRAGEN/RefGenIntro.htm
# https://support-docs.illumina.com/SW/DRAGEN_v41/Content/SW/DRAGEN/RefGenPipe_fDG.htm
# Import a reference:
# https://support-docs.illumina.com/IN/NovaSeqX/Content/IN/NovaSeqX/ImportResources.htm

if ($do_germline_alignment) {

  my @to_align = ();
  my @ref_matches = keys %REFERENCE_MAPING;
  for my $p ( @{$products} ) {
    my $r = $p->[$LIST_INDEX_REF];
    if (!$r || ($r =~ /Not suitable/xmsi)) {
      next;
    }
    if ( !$do_rna_alignment_test->($r) ) {
      # The option for all variant callers includes Small, Structural, CNV,
      # Repeat Expansions, ROH, CYP2D6.
      my $match = first { $r =~ /$_/xms} @ref_matches;
      if ($match) {
        push @to_align, [$p->[1],
                         $REFERENCE_MAPING{$match},
                         $variant_calling_mode];
      }
    }
  }
  if (@to_align) {
    $add_line->(qw([DragenGermline_Data]));
    $add_line->(qw(Sample_ID ReferenceGenomeDir VariantCallingMode));
    # ReferenceGenomeDir is the Genome name consisting of alphanumeric
    # string with _ or -.
    for (@to_align) {
        $add_line->(@{$_});
    }
    $add_line->();
  }
}

########################################
# DragenEnrichment_Settings section
########################################

########################################
# DragenEnrichment_Data section
########################################

########################################
# DragenRNA_Settings section
########################################

########################################
# DragenRNA_Data section
########################################

open my $fh, q[>], $FILE_NAME or croak "Failed to open $FILE_NAME for writing";
my $csv = Text::CSV->new({
  eol      => qq[\n],
  sep_char => q[,],
});

# Pad the rows and print.
my $max_num_columns = max map { scalar @{$_} } @all_lines;
for my $line (@all_lines) {
  my @columns = @{$line};
  while (scalar @columns < $max_num_columns) {
    push @columns, q[];
  }
  $csv->print($fh, \@columns);
}

close $fh or carp "Problems closing $FILE_NAME";

1;

=head1 NAME

npg_samplesheet_generator_NovaSeqXSeries

=head1 USAGE

  C<npg_samplesheet_generator_NovaSeqXSeries>
  C<npg_samplesheet_generator_NovaSeqXSeries --help>
  C<npg_samplesheet_generator_NovaSeqXSeries --varcall SmallVariantCaller>

  The C<--varcall> argument defines the variant calling mode. If not set
  the mode defaults to C<None>, other valid options are C<SmallVariantCaller>
  and C<AllVariantCallers>.

=head1 REQUIRED ARGUMENTS

None

=head1 OPTIONS

  C<varcall> - variant calling mode, defaults to C<None>, other valid options
               C<SmallVariantCaller> and C<AllVariantCallers>

=head1 DESCRIPTION

Samplesheet generation to initiate on-board DRAGEN analysis on the
NovaSeq Series X instrument.

See specification in
L<https://support-docs.illumina.com/SHARE/SampleSheetv2/Content/SHARE/SampleSheetv2/Settings_fNV_mX.htm> 

A full listing of analysis options is available in
L<https://support-docs.illumina.com/SW/DRAGEN_v41/Content/SW/DRAGEN/OptionReference.htm>

=head1 EXIT STATUS

0

=head1 DIAGNOSTICS

=head1 CONFIGURATION

Access to the ml warehouse database is required.

=head1 DEPENDENCIES

=over

=item strict

=item warnings

=item Carp

=item Text::CSV

=item Readonly

=item List::MoreUtils

=item List::Util

=item Getopt::Long

=item Pod::Usage

=item st::api::lims

=back

=head1 BUGS AND LIMITATIONS

=head1 INCOMPATIBILITIES

=head1 AUTHOR

Marina Gourtovaia E<lt>mg8@sanger.ac.ukE<gt>

=head1 LICENSE AND COPYRIGHT

Copyright (C) 2023 Genome Research Ltd

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

=cut
